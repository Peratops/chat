<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Company Chat Pro</title>
    
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAPnAAAD5wHDtfxxAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAU5JREFUWIXt1rFqFFEYxfHfTEwhSBolRSxEsVwUKxErHyKoffI6AWsbIT5AyBOkEPElrKxWETURNolkj8Xu6uxUO5PkJsX+qzt37nfP4dy5wydJneRtkpN0Y5xEkjtJRgusP01ymGQ3yd1pLUm2Owq3Daz3qB0leZVEleQDnutOUGMdwx71Z9io8ahH8UWwgjdVkjQmx3iCLwtu8qOD4CpeYrcx97Nt4DMedti0D0OTY4Nx3Xr555LF4aAxTttAca7CQPPIr8TAHMsElgksE1gmcO0SKG7oRuv5AW7j+yVq/va/jzirkhzhVmPBCMcLbBQTs+eiSvIJT3vUznrCc1Gbb5GKUyVZwTu8NmkUF+VCEqjmW8IifMSz6XivtIFV/MJNfMOg9L1/PBWHLXwtbWAW/Q72Kf8NvMd9vMAp5X+997A5E6dsAmsYmNyCf/wF4VFBnEfh1mQAAAAASUVORK5CYII=">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .sidebar { transition: transform 0.3s ease-in-out; }
        .notification-popup {
            animation: slideIn 0.5s ease-out forwards, fadeOut 0.5s ease-in 4.5s forwards;
        }
        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .break-words {
             overflow-wrap: break-word;
             word-wrap: break-word;
             word-break: break-all;
        }
        .emoticon {
            width: 20px;
            height: 20px;
            display: inline-block;
            vertical-align: bottom;
        }
    </style>
</head>
<body class="bg-gray-900 overflow-hidden">
    <div id="root"></div>

    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, serverTimestamp, doc, setDoc, query, updateDoc, where, getDocs, arrayUnion, arrayRemove, getDoc, writeBatch, deleteDoc, limit, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, uploadBytesResumable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        window.firebaseServices = {
            initializeApp,
            getAuth, signInAnonymously, onAuthStateChanged,
            getFirestore, collection, addDoc, onSnapshot, serverTimestamp, doc, setDoc, query, updateDoc, where, getDocs, arrayUnion, arrayRemove, getDoc, writeBatch, deleteDoc, limit, orderBy,
            getStorage, ref, uploadBytes, getDownloadURL, deleteObject, uploadBytesResumable
        };
    </script>

    <script type="text/babel" data-presets="react">
        const { useState, useEffect, useRef } = React;
        
        const firebaseConfig = {
            apiKey: "AIzaSyCcqfbDluQqNBDCElYzVOg3pBV5bG46Sjc",
            authDomain: "chat-39642.firebaseapp.com",
            databaseURL: "https://chat-39642-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "chat-39642",
            storageBucket: "chat-39642.appspot.com",
            messagingSenderId: "593980460968",
            appId: "1:593980460968:web:7bdcd3f9ae9c1cb013179d",
            measurementId: "G-DB1WNLYV81"
        };

        const appId = 'company-chat-v1';
        
        const generateUniqueFriendCode = async (services) => {
            const { db, collection, query, where, getDocs } = services;
            const usersRef = collection(db, `artifacts/${appId}/public/data/users`);
            let code;
            let isUnique = false;
            while (!isUnique) {
                code = String(Math.floor(1000 + Math.random() * 9000));
                const q = query(usersRef, where("friendCode", "==", code));
                const snapshot = await getDocs(q);
                if (snapshot.empty) {
                    isUnique = true;
                }
            }
            return code;
        };
        
        const playNotificationSound = () => {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);

            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        };


        function App() {
            const [services, setServices] = useState(null);
            const [user, setUser] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [error, setError] = useState(null);

            useEffect(() => {
                let servicesInstance = null;
                try {
                    if (window.firebaseServices) {
                        const s = window.firebaseServices;
                        const app = s.initializeApp(firebaseConfig);
                        const auth = s.getAuth(app);
                        const db = s.getFirestore(app);
                        const storage = s.getStorage(app);
                        servicesInstance = { app, auth, db, storage, ...s };
                        setServices(servicesInstance);
                    } else {
                        setError("Firebase scripts did not load.");
                        return;
                    }
                } catch(e) {
                    console.error("Firebase Init Error:", e);
                    setError("Could not initialize Firebase. Please check your configuration.");
                    return;
                }

                const authUnsubscribe = servicesInstance.onAuthStateChanged(servicesInstance.auth, async (authUser) => {
                    if (authUser) {
                        const userDocRef = servicesInstance.doc(servicesInstance.db, `artifacts/${appId}/public/data/users/${authUser.uid}`);
                        
                        servicesInstance.updateDoc(userDocRef, { lastSeen: servicesInstance.serverTimestamp() }).catch(() => {});
                        const presenceInterval = setInterval(() => {
                           servicesInstance.updateDoc(userDocRef, { lastSeen: servicesInstance.serverTimestamp() }).catch(() => {});
                        }, 60000);

                        const userProfileUnsubscribe = servicesInstance.onSnapshot(userDocRef, async (userDoc) => {
                            if (userDoc.exists()) {
                                const userData = userDoc.data();
                                if (!userData.friendCode) {
                                    const newFriendCode = await generateUniqueFriendCode(servicesInstance);
                                    await servicesInstance.updateDoc(userDocRef, { friendCode: newFriendCode });
                                    setUser({ ...authUser, ...userData, friendCode: newFriendCode });
                                } else {
                                    setUser({ ...authUser, ...userData });
                                }
                            } else {
                                const newFriendCode = await generateUniqueFriendCode(servicesInstance);
                                await servicesInstance.setDoc(userDocRef, {
                                    uid: authUser.uid,
                                    displayName: `User-${authUser.uid.slice(-6)}`,
                                    photoURL: '',
                                    lastSeen: servicesInstance.serverTimestamp(),
                                    friends: [],
                                    friendCode: newFriendCode,
                                    customEmoticons: [],
                                });
                            }
                            setIsAuthReady(true);
                        });
                        
                        return () => {
                            userProfileUnsubscribe();
                            clearInterval(presenceInterval);
                        };
                    } else {
                        servicesInstance.signInAnonymously(servicesInstance.auth).catch(authError => {
                             console.error("Anonymous Sign-In Error: ", authError);
                             setError("Could not authenticate with the server.");
                        });
                    }
                });

                return () => authUnsubscribe();
            }, []);

            if (error) return <ErrorMessage message={error} />;
            if (!isAuthReady || !user || !services) return <LoadingScreen />;

            return <ChatLayout user={user} services={services} />;
        }
        
        function LoadingScreen() {
            return (
                <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
                    <div className="text-center">
                        <svg className="animate-spin h-10 w-10 text-purple-500 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        <p className="text-xl">Connecting to Secure Chat...</p>
                    </div>
                </div>
            );
        }

        function ErrorMessage({ message }) {
            return (
                <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
                    <div className="text-center p-8 bg-gray-800 rounded-lg shadow-lg max-w-md">
                        <h2 className="text-2xl font-bold text-red-500 mb-4">Connection Failed</h2>
                        <p className="text-gray-300">{message}</p>
                    </div>
                </div>
            );
        }

        function ChatLayout({ user, services }) {
            const [isSidebarOpen, setIsSidebarOpen] = useState(window.innerWidth >= 768);
            const [activeRoom, setActiveRoom] = useState(null);
            const [notification, setNotification] = useState(null);
            const [unreadRooms, setUnreadRooms] = useState([]);
            const [showCreateRoomModal, setShowCreateRoomModal] = useState(false);
            const [showJoinRoomModal, setShowJoinRoomModal] = useState(false);
            const [showAddFriendModal, setShowAddFriendModal] = useState(false);
            const [showProfileModal, setShowProfileModal] = useState(false);
            const [showEmoticonModal, setShowEmoticonModal] = useState(false);
            const layoutRef = useRef(null);
            
            useEffect(() => {
                const handleResize = () => {
                    setIsSidebarOpen(window.innerWidth >= 768);
                    if (layoutRef.current) {
                        layoutRef.current.style.height = `${window.innerHeight}px`;
                    }
                };
                window.addEventListener('resize', handleResize);
                handleResize(); // Initial call
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const onRoomSelect = (room) => {
                setActiveRoom(room);
                if (room) {
                    setUnreadRooms(prev => prev.filter(id => id !== room.id));
                }
                if(window.innerWidth < 768) {
                    setIsSidebarOpen(false);
                }
            }

            return (
                <div ref={layoutRef} className="flex antialiased text-gray-200 bg-gray-900">
                    {notification && <NotificationPopup notification={notification} setNotification={setNotification} setActiveRoom={onRoomSelect} />}
                    <Sidebar 
                        user={user} 
                        services={services} 
                        isOpen={isSidebarOpen} 
                        setIsOpen={setIsSidebarOpen} 
                        onRoomSelect={onRoomSelect}
                        activeRoomId={activeRoom?.id}
                        setNotification={setNotification}
                        unreadRooms={unreadRooms}
                        setUnreadRooms={setUnreadRooms}
                        setShowCreateRoomModal={setShowCreateRoomModal}
                        setShowJoinRoomModal={setShowJoinRoomModal}
                        setShowAddFriendModal={setShowAddFriendModal}
                        setShowProfileModal={setShowProfileModal}
                        setShowEmoticonModal={setShowEmoticonModal}
                    />
                    <MainChatArea 
                        user={user} 
                        services={services} 
                        activeRoom={activeRoom}
                        isSidebarOpen={isSidebarOpen}
                        setIsSidebarOpen={setIsSidebarOpen}
                    />

                    {showCreateRoomModal && <CreateRoomModal user={user} services={services} closeModal={() => setShowCreateRoomModal(false)} />}
                    {showJoinRoomModal && <JoinRoomModal user={user} services={services} closeModal={() => setShowJoinRoomModal(false)} />}
                    {showAddFriendModal && <AddFriendModal user={user} services={services} closeModal={() => setShowAddFriendModal(false)} />}
                    {showProfileModal && <ProfileModal user={user} services={services} closeModal={() => setShowProfileModal(false)} />}
                    {showEmoticonModal && <EmoticonManagerModal user={user} services={services} closeModal={() => setShowEmoticonModal(false)} />}
                </div>
            );
        }

        function Sidebar({ user, services, isOpen, setIsOpen, onRoomSelect, activeRoomId, setNotification, unreadRooms, setUnreadRooms, setShowCreateRoomModal, setShowJoinRoomModal, setShowAddFriendModal, setShowProfileModal, setShowEmoticonModal }) {
            const [rooms, setRooms] = useState([]);
            const [friends, setFriends] = useState([]);
            const [friendRequests, setFriendRequests] = useState([]);
            const [copiedCode, setCopiedCode] = useState(false);
            const activeRoomIdRef = useRef(activeRoomId);

            useEffect(() => {
                activeRoomIdRef.current = activeRoomId;
            }, [activeRoomId]);

            useEffect(() => {
                const roomsPath = `artifacts/${appId}/public/data/rooms`;
                const q = services.query(services.collection(services.db, roomsPath), services.where('members', 'array-contains', user.uid));
                const unsubscribe = services.onSnapshot(q, (snapshot) => {
                    setRooms(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                });
                return unsubscribe;
            }, [user.uid]);

            useEffect(() => {
                if (rooms.length === 0) return;
                const unsubscribers = rooms.map(room => {
                    const messagesPath = `artifacts/${appId}/public/data/rooms/${room.id}/messages`;
                    const q = services.query(services.collection(services.db, messagesPath), services.orderBy('createdAt', 'desc'), services.limit(1));
                    return services.onSnapshot(q, (snapshot) => {
                        snapshot.docChanges().forEach((change) => {
                            if (change.type === 'added') {
                                const message = change.doc.data();
                                if (message.uid !== user.uid && room.id !== activeRoomIdRef.current) {
                                     setUnreadRooms(prev => [...new Set([...prev, room.id])]);
                                     playNotificationSound();
                                     const isRecent = (Date.now() - (message.createdAt?.toMillis() || 0)) < 5000;
                                     if (isRecent) {
                                         const text = message.text || (message.imageUrl ? 'Sent an image' : 'New message');
                                         setNotification({
                                            from: message.displayName, text: text, photoURL: message.photoURL, room: room
                                        });
                                     }
                                }
                            }
                        });
                    });
                });
                return () => unsubscribers.forEach(unsub => unsub && unsub());
            }, [rooms, user.uid]);
            
            useEffect(() => {
                 if (!user.friends || user.friends.length === 0) { setFriends([]); return; };
                const usersPath = `artifacts/${appId}/public/data/users`;
                const q = services.query(services.collection(services.db, usersPath), services.where('uid', 'in', user.friends));
                const unsubscribe = services.onSnapshot(q, (snapshot) => {
                    setFriends(snapshot.docs.map(d => d.data()));
                });
                return unsubscribe;
            }, [user.friends]);

            useEffect(() => {
                const requestsPath = `artifacts/${appId}/public/data/users/${user.uid}/friendRequests`;
                const q = services.query(services.collection(services.db, requestsPath), services.where('status', '==', 'pending'));
                const unsubscribe = services.onSnapshot(q, (snapshot) => {
                    setFriendRequests(snapshot.docs.map(d => ({id: d.id, ...d.data()})));
                });
                return unsubscribe;
            }, [user.uid]);

            const copyFriendCode = () => {
                const textArea = document.createElement("textarea");
                textArea.value = user.friendCode;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    setCopiedCode(true);
                    setTimeout(() => setCopiedCode(false), 2000);
                } catch (err) {
                    console.error('Failed to copy friend code: ', err);
                }
                document.body.removeChild(textArea);
            };

            const groupChats = rooms.filter(r => !r.isDM);
            const dmRooms = rooms.filter(r => r.isDM);
            
            return (
                <React.Fragment>
                    {isOpen && <div onClick={() => setIsOpen(false)} className="fixed inset-0 bg-black/50 z-20 md:hidden"></div>}
                    <aside className={`sidebar fixed top-0 left-0 h-full w-64 bg-gray-900 border-r border-gray-700 flex-shrink-0 z-30 flex flex-col transform ${isOpen ? 'translate-x-0' : '-translate-x-full'} md:relative md:translate-x-0`}>
                        <div className="flex-shrink-0 px-4 py-3 border-b border-gray-700 flex justify-between items-center">
                             <div className="w-full flex flex-col items-center">
                                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJkAAAAqCAYAAACgAvlhAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAwtJREFUeJzt3E9IFVEUx/Gv0zO1wP5AQSSCLQoiqbcpglq1CYO2uYgKo3YFIS0iiMI2EbUoMmhRUBC0KmpVREG0qiiRElqoEAT94VkaWlF2WtwZnBmePntv7p1mPB+44L2MnMPw05l5oxcRwR/LRKRHRAZE5Lu41xXqJRi9sWM6yhxja7THaj+ucHyDiBwSkeciMlrLiZiFkog8EZHdIlI3TT8XLfdQzoiI9IlIt4gsDHopYBSBu0ALqhrLgXvARkf1lgJb/dEJ7ALGHdWeyRJ/rAe6gJ3AoOcv3kEDVi0PuIm7gMXtAC6lVHsmazG5WlAADgOtsQO++MOlb47rJWU7sC22NgF8sFizBZgfmu8FzgP9obUSMGSxh3JWAg2h+TpgDyLyJnZdPSrJ3dfUOrJwT3YtdtwNMfdnNntr9vsJO+3w3Ew3PBE5F+vrtQe0hZI3Apx1Gf0cWBWbnwR+Wq45Bpyq0Eca/gAnAAmttXpAU2ghq5esNDXF5q7O4WiFPtIyDkyG5mNeWp2ouUNDpqzTkCnrNGTKOg2Zsk5DpqzTkCnrNGTKukLlQ/4rx4B9jmotclQn97IWsi1pN6D+nV4ulXVZ+02WBW+JviC2ZZ6DGonIWsiOA88c1WoDrlTxfYuTbiTrshayPuCho1rtjurkXtZClgVfcXe5bHZQp2YasuStAT45qFMEXjqoUzN9ulTWaciUdRoyZZ2GTFmnIVPWeUQft+vSakTll0f0cXsFZl8HpRJTAF5h/tUeoB64D/RiPlR06QUw7LimcqAAXGYqZAAbqO6dXa32oyHLi9VM3Xr99jBbRl1Nrx+VQ8OYzV6GgHfB0+VBoAf4kVZXKr+Cd5eTmI0yLgAdmM07Gh330l9m7QFmc5HAoKNeAD4DZ0Lz6bZhug48Cs0nrHUU9ZFofwOO6s5GN1PZKtWJuPiDATWHtBH9gezUD2NV0jaFvr4N3NKQqaQF25q+Bw6AvlZSydsM/MJsmFwCDZlKVj1m5+sjwNNgUUOmklTE3IdFduPWkKkkNeLfh4X9BboZZUSU9g5jAAAAAElFTkSuQmCC" alt="Company Chat Pro Logo" className="h-12 w-auto"/>
                                <div className="text-xs text-gray-400 mt-2 flex items-center">
                                    <span>Code: {user.friendCode}</span>
                                    <button onClick={copyFriendCode} className="ml-2 p-1 bg-gray-700 rounded hover:bg-gray-600">
                                        {copiedCode ? <svg className="w-3 h-3 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path></svg> : <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>}
                                    </button>
                                </div>
                             </div>
                             <button onClick={() => setIsOpen(false)} className="absolute top-3 right-3 p-1 text-gray-400 hover:text-white md:hidden">
                                 <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                             </button>
                        </div>

                        <div className="flex-grow p-4 overflow-y-auto">
                            {friendRequests.length > 0 && <Notifications requests={friendRequests} user={user} services={services} />}
                            <CollapsibleRoomList title="Direct Messages" rooms={dmRooms} onSelect={onRoomSelect} activeRoomId={activeRoomId} user={user} services={services} unreadRooms={unreadRooms} />
                            <CollapsibleRoomList title="Group Chats" rooms={groupChats} onSelect={onRoomSelect} activeRoomId={activeRoomId} user={user} services={services} unreadRooms={unreadRooms} />
                            <FriendList friends={friends} user={user} services={services} onRoomSelect={onRoomSelect} />
                        </div>

                        <div className="flex-shrink-0 p-2 border-t border-gray-700">
                            <button onClick={() => setShowCreateRoomModal(true)} className="w-full text-left text-sm p-2 rounded-md hover:bg-gray-700">Create Group</button>
                            <button onClick={() => setShowJoinRoomModal(true)} className="w-full text-left text-sm p-2 rounded-md hover:bg-gray-700">Join Group</button>
                            <button onClick={() => setShowAddFriendModal(true)} className="w-full text-left text-sm p-2 rounded-md hover:bg-gray-700">Add Friend</button>
                            <button onClick={() => setShowProfileModal(true)} className="w-full text-left text-sm p-2 rounded-md hover:bg-gray-700">Edit Profile</button>
                            <button onClick={() => setShowEmoticonModal(true)} className="w-full text-left text-sm p-2 rounded-md hover:bg-gray-700">Custom Emoticons</button>
                             <p className="text-xs text-gray-500 text-center mt-2">v 5.9</p>
                        </div>
                    </aside>
                </React.Fragment>
            );
        }
        
        function NotificationPopup({ notification, setNotification, setActiveRoom }) {
            const { from, text, photoURL, room } = notification;
            useEffect(() => {
                const timer = setTimeout(() => { setNotification(null); }, 5000);
                return () => clearTimeout(timer);
            }, [notification]);
            const handleClick = () => { setActiveRoom(room); setNotification(null); };
            return (
                <div className="notification-popup fixed top-5 right-5 max-w-sm w-full bg-gray-800 shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden z-50 cursor-pointer" onClick={handleClick}>
                    <div className="p-4"><div className="flex items-start"><div className="flex-shrink-0"><img className="h-10 w-10 rounded-full" src={photoURL || `https://placehold.co/40x40/374151/E5E7EB?text=${from[0]}`} alt="" /></div><div className="ml-3 w-0 flex-1 pt-0.5"><p className="text-sm font-medium text-white">{from}</p><p className="mt-1 text-sm text-gray-400 truncate">{text}</p></div></div></div>
                </div>
            );
        }

        function Notifications({requests, user, services}) {
            const handleRequest = async (requestId, fromId, accept = false) => {
                const batch = services.writeBatch(services.db);
                const requestRef = services.doc(services.db, `artifacts/${appId}/public/data/users/${user.uid}/friendRequests`, requestId);
                if (accept) {
                    const userRef = services.doc(services.db, `artifacts/${appId}/public/data/users`, user.uid);
                    const friendRef = services.doc(services.db, `artifacts/${appId}/public/data/users`, fromId);
                    batch.update(userRef, { friends: services.arrayUnion(fromId) });
                    batch.update(friendRef, { friends: services.arrayUnion(user.uid) });
                }
                batch.delete(requestRef);
                await batch.commit();
            };
            return (
                <div className="mb-4">
                    <h2 className="text-sm font-semibold text-gray-400 mb-2 px-2">Friend Requests ({requests.length})</h2>
                    <ul>{requests.map(req => (<li key={req.id} className="p-2 rounded-md bg-gray-800 mb-2"><p className="text-sm">{req.displayName} wants to be your friend.</p><div className="flex justify-end space-x-2 mt-2"><button onClick={() => handleRequest(req.id, req.from, true)} className="text-xs bg-green-600 hover:bg-green-700 px-2 py-1 rounded">Accept</button><button onClick={() => handleRequest(req.id, req.from, false)} className="text-xs bg-red-600 hover:bg-red-700 px-2 py-1 rounded">Decline</button></div></li>))}</ul>
                </div>
            )
        }

        function CollapsibleRoomList({ title, rooms, onSelect, activeRoomId, user, services, unreadRooms }) {
            const [isOpen, setIsOpen] = useState(true);
            return (
                <div className="mb-4">
                    <button onClick={() => setIsOpen(!isOpen)} className="w-full flex justify-between items-center text-sm font-semibold text-gray-400 mb-2 px-2 focus:outline-none">
                        <span>{title}</span>
                        <svg className={`w-4 h-4 transform transition-transform ${isOpen ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    {isOpen && <RoomList rooms={rooms} onSelect={onSelect} activeRoomId={activeRoomId} user={user} services={services} unreadRooms={unreadRooms} />}
                </div>
            );
        }

        function RoomList({ rooms, onSelect, activeRoomId, user, services, unreadRooms }) {
            const [contextMenu, setContextMenu] = useState({visible: false, x: 0, y: 0, room: null});
            const getDmName = (room) => {
                if (!room.isDM || !room.members || !user) return room.name;
                const otherUserId = room.members.find(uid => uid !== user.uid);
                return room.memberDetails?.[otherUserId]?.displayName || room.name;
            }
            const handleRightClick = (e, room) => { e.preventDefault(); setContextMenu({ visible: true, x: e.clientX, y: e.clientY, room }); }
            const closeContextMenu = () => setContextMenu({visible: false, x:0, y:0, room: null});
            useEffect(() => { document.addEventListener('click', closeContextMenu); return () => document.removeEventListener('click', closeContextMenu); }, []);
            
            const handleLeaveRoom = async (room) => {
                closeContextMenu();
                if (room.isDM) return;
                const roomRef = services.doc(services.db, `artifacts/${appId}/public/data/rooms`, room.id);
                const messagesPath = `artifacts/${appId}/public/data/rooms/${room.id}/messages`;
                await services.addDoc(services.collection(services.db, messagesPath), {
                    type: 'system', text: `${user.displayName} has left the group.`, createdAt: services.serverTimestamp(), uid: 'system'
                });
                await services.updateDoc(roomRef, { members: services.arrayRemove(user.uid) });
                if (activeRoomId === room.id) { onSelect(null); }
            };
            
            const handleCopyId = (room) => {
                closeContextMenu();
                const textArea = document.createElement("textarea");
                textArea.value = room.id;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert('Group ID copied to clipboard!');
                } catch (err) {
                    console.error('Failed to copy room ID: ', err);
                    alert('Failed to copy Group ID.');
                }
                document.body.removeChild(textArea);
            };
            
            return (
                <div>
                    <ul>{rooms.map(room => (<li key={room.id} onClick={() => onSelect(room)} onContextMenu={(e) => handleRightClick(e, room)} className={`flex items-center justify-between p-2 rounded-md cursor-pointer text-sm ${activeRoomId === room.id ? 'bg-blue-900/70' : 'hover:bg-gray-700/50'}`}><span className="truncate"># {room.isDM ? getDmName(room) : room.name}</span>{unreadRooms.includes(room.id) && <span className="w-2.5 h-2.5 bg-red-500 rounded-full"></span>}</li>))}</ul>
                     {contextMenu.visible && (
                         <div style={{ top: contextMenu.y, left: contextMenu.x }} className="absolute bg-gray-800 border border-gray-600 rounded-md shadow-lg py-1 z-50">
                             {!contextMenu.room.isDM && <button onClick={() => handleCopyId(contextMenu.room)} className="block w-full text-left px-4 py-2 text-sm text-white hover:bg-blue-600">Copy Group ID</button>}
                             {!contextMenu.room.isDM && <button onClick={() => handleLeaveRoom(contextMenu.room)} className="block w-full text-left px-4 py-2 text-sm text-red-500 hover:bg-red-600 hover:text-white">Leave Group</button>}
                         </div>
                     )}
                </div>
            )
        }
        
        function FriendList({ friends, user, services, onRoomSelect }) {
            const isOnline = (friend) => {
                if (!friend.lastSeen) return false;
                const lastSeenMillis = friend.lastSeen.toMillis();
                const nowMillis = Date.now();
                return (nowMillis - lastSeenMillis) < 120000; // 2 minutes
            };
            const handleDirectMessage = async (friend) => {
                const dmId = [user.uid, friend.uid].sort().join('_');
                const dmRoomRef = services.doc(services.db, `artifacts/${appId}/public/data/rooms`, `dm_${dmId}`);
                const docSnap = await services.getDoc(dmRoomRef);
                let roomData;
                if (docSnap.exists()) {
                    roomData = {id: docSnap.id, ...docSnap.data()};
                } else {
                    roomData = { id: `dm_${dmId}`, name: `DM with ${friend.displayName}`, isDM: true, type: 'private', createdBy: user.uid, createdAt: services.serverTimestamp(), members: [user.uid, friend.uid], memberDetails: { [user.uid]: { displayName: user.displayName, photoURL: user.photoURL }, [friend.uid]: { displayName: friend.displayName, photoURL: friend.photoURL }}};
                    await services.setDoc(dmRoomRef, roomData);
                }
                onRoomSelect(roomData);
            };
            return (<div className="mb-4"><h2 className="text-sm font-semibold text-gray-400 mb-2 px-2">Friends</h2><ul>{friends.map(friend => (<li key={friend.uid} onClick={() => handleDirectMessage(friend)} className="flex items-center p-2 rounded-md text-sm hover:bg-gray-700/50 cursor-pointer"><span className={`w-2 h-2 rounded-full mr-3 flex-shrink-0 ${isOnline(friend) ? 'bg-green-500' : 'bg-red-500'}`}></span><img src={friend.photoURL || `https://placehold.co/32x32/374151/E5E7EB?text=${(friend.displayName || 'U')[0]}`} alt={friend.displayName} className="w-6 h-6 rounded-full mr-2" /><span className="truncate">{friend.displayName}</span></li>))}</ul></div>)
        }

        function MainChatArea({ user, services, activeRoom, isSidebarOpen, setIsSidebarOpen }) {
            const [messages, setMessages] = useState([]);
            const [allUsers, setAllUsers] = useState({});
            const [replyTo, setReplyTo] = useState(null);
            const [isMenuOpen, setIsMenuOpen] = useState(false);
            const [showMembersModal, setShowMembersModal] = useState(false);
            const [showMediaModal, setShowMediaModal] = useState(false);
            const [showLinksModal, setShowLinksModal] = useState(false);
            const [showSearch, setShowSearch] = useState(false);
            const [searchQuery, setSearchQuery] = useState("");
            const messagesEndRef = useRef(null);
            const menuRef = useRef(null);

            const getDmName = (room) => {
                if (!room?.isDM || !room.members || !user) return room?.name;
                const otherUserId = room.members.find(uid => uid !== user.uid);
                return room.memberDetails?.[otherUserId]?.displayName || room.name;
            }

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (menuRef.current && !menuRef.current.contains(event.target)) {
                        setIsMenuOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, [menuRef]);

            useEffect(() => {
                if (!activeRoom) { 
                    setMessages([]); 
                    return; 
                }
                setReplyTo(null);
                setIsMenuOpen(false);
                const messagesPath = `artifacts/${appId}/public/data/rooms/${activeRoom.id}/messages`;
                const q = services.query(services.collection(services.db, messagesPath), services.orderBy('createdAt'));
                const unsubscribe = services.onSnapshot(q, (snapshot) => {
                    setMessages(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                });
                
                const usersPath = `artifacts/${appId}/public/data/users`;
                const usersUnsubscribe = services.onSnapshot(services.collection(services.db, usersPath), (snapshot) => {
                    const usersData = {};
                    snapshot.forEach(doc => {
                        usersData[doc.id] = doc.data();
                    });
                    setAllUsers(usersData);
                });

                return () => {
                    unsubscribe();
                    usersUnsubscribe();
                };
            }, [activeRoom]);

            useEffect(() => { 
                if (!searchQuery) {
                    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); 
                }
            }, [messages, searchQuery]);
            
            const handleRemoveMessage = async (messageId) => {
                const messageRef = services.doc(services.db, `artifacts/${appId}/public/data/rooms/${activeRoom.id}/messages`, messageId);
                await services.updateDoc(messageRef, {
                    text: '',
                    imageUrl: null,
                    isDeleted: true,
                    deletedBy: user.displayName
                });
            };

            const handleEditMessage = async (messageId, newText, originalText) => {
                const messageRef = services.doc(services.db, `artifacts/${appId}/public/data/rooms/${activeRoom.id}/messages`, messageId);
                await services.updateDoc(messageRef, {
                    text: newText,
                    editedAt: services.serverTimestamp(),
                    editHistory: services.arrayUnion({
                        originalText: originalText,
                        editedAt: new Date().toISOString()
                    })
                });
            };

            const displayedMessages = messages.filter(msg => 
                searchQuery ? (msg.text && msg.text.toLowerCase().includes(searchQuery.toLowerCase())) : true
            );

            return (
                <main className="flex-1 flex flex-col h-full">
                    <header className="flex-shrink-0 bg-gray-900/80 backdrop-blur-sm border-b border-gray-700 p-3 flex items-center justify-between z-10">
                        <div className="flex items-center min-w-0">
                             <button onClick={() => setIsSidebarOpen(true)} className="p-1 text-gray-400 hover:text-white mr-2 md:hidden">
                                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                             </button>
                            <h2 className="text-xl font-semibold truncate">
                                {activeRoom ? `# ${getDmName(activeRoom)}` : 'Welcome'}
                            </h2>
                        </div>
                        {activeRoom && (
                             <div className="relative" ref={menuRef}>
                                <button onClick={() => setIsMenuOpen(prev => !prev)} className="p-1 text-gray-400 hover:text-white">
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                </button>
                                {isMenuOpen && (
                                    <ChatMenuOverlay 
                                        room={activeRoom} 
                                        onClose={() => setIsMenuOpen(false)} 
                                        onViewMembers={() => setShowMembersModal(true)}
                                        onShowMedia={() => setShowMediaModal(true)}
                                        onShowLinks={() => setShowLinksModal(true)}
                                        onShowSearch={() => setShowSearch(true)}
                                    />
                                )}
                            </div>
                        )}
                    </header>

                    {showSearch && <SearchBar onSearch={setSearchQuery} onClose={() => { setShowSearch(false); setSearchQuery(""); }} />}
                    
                    <div className="flex-1 min-h-0 p-4 sm:p-6 overflow-y-auto">
                        {!activeRoom && (
                             <div className="flex h-full flex-col items-center justify-center text-center p-4">
                                <div>
                                    <h2 className="text-2xl font-bold">Welcome {user.displayName}</h2>
                                    <p className="text-gray-400 mt-2">Select a room or a friend to start chatting.</p>
                                </div>
                            </div>
                        )}
                        {activeRoom && displayedMessages.map(msg => (
                            <MessageBubble 
                                key={msg.id} 
                                message={msg} 
                                isOwnMessage={msg.uid === user.uid} 
                                onReply={setReplyTo} 
                                searchQuery={searchQuery}
                                onRemove={handleRemoveMessage}
                                onEdit={handleEditMessage}
                                allUsers={allUsers}
                            />
                        ))}
                        <div ref={messagesEndRef} />
                    </div>
                    
                    {activeRoom && <MessageInput user={user} services={services} activeRoom={activeRoom} replyTo={replyTo} setReplyTo={setReplyTo} allUsers={allUsers} />}

                    {showMembersModal && <ViewMembersModal room={activeRoom} services={services} closeModal={() => setShowMembersModal(false)} />}
                    {showMediaModal && <MediaViewerModal messages={messages} closeModal={() => setShowMediaModal(false)} />}
                    {showLinksModal && <LinksViewerModal messages={messages} closeModal={() => setShowLinksModal(false)} />}
                </main>
            );
        }

        function SearchBar({ onSearch, onClose }) {
            const [query, setQuery] = useState("");
            const inputRef = useRef(null);

            useEffect(() => {
                inputRef.current?.focus();
            }, []);
            
            const handleChange = (e) => {
                setQuery(e.target.value);
                onSearch(e.target.value);
            }

            return (
                <div className="flex-shrink-0 p-2 border-b border-gray-700 bg-gray-800 flex items-center">
                    <input
                        ref={inputRef}
                        type="text"
                        value={query}
                        onChange={handleChange}
                        placeholder="Search messages..."
                        className="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:border-purple-500"
                    />
                    <button onClick={onClose} className="p-2 text-gray-400 hover:text-white ml-2">
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            )
        }

        function ChatMenuOverlay({ room, onClose, onViewMembers, onShowMedia, onShowLinks, onShowSearch }) {
            return (
                <div className="absolute top-full right-0 mt-2 w-56 bg-gray-800 border border-gray-700 rounded-md shadow-lg z-20 py-1">
                    <button onClick={() => { onShowSearch(); onClose(); }} className="w-full text-left px-4 py-2 text-sm text-white hover:bg-blue-600">Search in conversation</button>
                    <button onClick={() => { onShowMedia(); onClose(); }} className="w-full text-left px-4 py-2 text-sm text-white hover:bg-blue-600">See Media files</button>
                    <button onClick={() => { onShowLinks(); onClose(); }} className="w-full text-left px-4 py-2 text-sm text-white hover:bg-blue-600">See Links</button>
                    {!room.isDM && <div className="border-t border-gray-700 my-1"></div>}
                    {!room.isDM && <button onClick={() => { onViewMembers(); onClose(); }} className="w-full text-left px-4 py-2 text-sm text-white hover:bg-blue-600">View Members</button>}
                </div>
            )
        }

        function ViewMembersModal({ room, services, closeModal }) {
            const [members, setMembers] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const fetchMembers = async () => {
                    setLoading(true);
                    if (!room.members || room.members.length === 0) {
                        setMembers([]);
                        setLoading(false);
                        return;
                    }
                    const usersRef = services.collection(services.db, `artifacts/${appId}/public/data/users`);
                    const q = services.query(usersRef, services.where('uid', 'in', room.members));
                    const snapshot = await services.getDocs(q);
                    const memberData = snapshot.docs.map(doc => doc.data());
                    setMembers(memberData);
                    setLoading(false);
                };
                fetchMembers();
            }, [room]);

            return (
                <Modal title="Group Members" closeModal={closeModal}>
                    {loading ? (
                        <p>Loading members...</p>
                    ) : (
                        <ul className="space-y-3 max-h-80 overflow-y-auto">
                           {members.map(member => (
                               <li key={member.uid} className="flex items-center">
                                   <img src={member.photoURL || `https://placehold.co/40x40/374151/E5E7EB?text=${(member.displayName || 'U')[0]}`} alt={member.displayName} className="w-10 h-10 rounded-full mr-3"/>
                                   <span className="text-white">{member.displayName}</span>
                               </li>
                           ))}
                        </ul>
                    )}
                </Modal>
            )
        }
        
        function SystemMessage({ text }) { return (<div className="text-center my-2"><span className="text-xs text-gray-500 bg-gray-800 px-3 py-1 rounded-full">{text}</span></div>); }
        
        const PRESET_EMOTICONS = {
            ':)': 'ðŸ˜Š',
            ':(': 'ï¿½',
            ':D': 'ðŸ˜„',
            ':P': 'ðŸ˜›',
            ':O': 'ðŸ˜®',
            ';)': 'ðŸ˜‰',
            '<3': 'â¤ï¸',
            'lol': 'ðŸ˜‚',
        };

        function ParsedMessageContent({ text, highlight, allUsers }) {
            if (!text) return null;

            const allEmoticons = { ...PRESET_EMOTICONS };
            Object.values(allUsers).forEach(user => {
                if (user.customEmoticons) {
                    user.customEmoticons.forEach(emoticon => {
                        allEmoticons[emoticon.shortcut] = emoticon.imageUrl;
                    });
                }
            });

            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const emoticonShortcuts = Object.keys(allEmoticons).map(shortcut => shortcut.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
            const mainRegex = new RegExp(`(${emoticonShortcuts}|${urlRegex.source})`, 'g');

            const parts = text.split(mainRegex).filter(Boolean);

            return (
                <span>
                    {parts.map((part, i) => {
                        if (allEmoticons[part]) {
                            const src = allEmoticons[part];
                            if (src.startsWith('http')) {
                                return <img key={i} src={src} alt={part} className="emoticon" />;
                            }
                            return <span key={i} className="emoticon">{src}</span>;
                        }
                        if (urlRegex.test(part)) {
                            return <a key={i} href={part} target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:underline">{part}</a>;
                        }
                        if (highlight) {
                             const highlightRegex = new RegExp(`(${highlight})`, 'gi');
                             const highlightParts = part.split(highlightRegex);
                             return highlightParts.map((hp, j) => 
                                highlightRegex.test(hp) ? <mark key={`${i}-${j}`} className="bg-yellow-400 text-black px-0.5 rounded">{hp}</mark> : hp
                             );
                        }
                        return part;
                    })}
                </span>
            );
        }

        function MessageBubble({ message, isOwnMessage, onReply, searchQuery, onRemove, onEdit, allUsers }) {
            const [contextMenu, setContextMenu] = useState({visible: false, x: 0, y: 0});
            const [isEditing, setIsEditing] = useState(false);
            const [showHistory, setShowHistory] = useState(false);
            const [editedText, setEditedText] = useState(message.text || "");
            const avatarSrc = message.photoURL || `https://placehold.co/32x32/374151/E5E7EB?text=${(message.displayName || 'U')[0]}`;

            const handleRightClick = (e) => {
                e.preventDefault();
                if (isOwnMessage) {
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY });
                }
            };
            
            const closeContextMenu = () => setContextMenu({visible: false, x:0, y:0});

            useEffect(() => {
                document.addEventListener('click', closeContextMenu);
                return () => document.removeEventListener('click', closeContextMenu);
            }, []);

            const handleSaveEdit = () => {
                if (editedText.trim() !== message.text) {
                    onEdit(message.id, editedText, message.text);
                }
                setIsEditing(false);
            };

            if (message.isDeleted) {
                return (
                     <div className="text-center my-2">
                        <span className="text-sm text-gray-500 italic">*{message.deletedBy} removed a message*</span>
                    </div>
                )
            }

            return (
                <div className={`flex my-2 group ${isOwnMessage ? 'justify-end' : 'justify-start'}`} onContextMenu={handleRightClick}>
                    <div className="flex items-end">
                        {!isOwnMessage && <img src={avatarSrc} alt={message.displayName} className="w-8 h-8 rounded-full mr-2 flex-shrink-0 self-end" />}
                        <div className={`flex flex-col space-y-1 text-sm max-w-xs ${isOwnMessage ? 'items-end' : 'items-start'}`}>
                            {!isOwnMessage && <div className="text-xs text-gray-400 mb-1 px-1">{message.displayName}</div>}
                            {message.replyTo && (<div className="text-xs bg-gray-800/50 border-l-2 border-purple-400 px-2 py-1 mb-1 rounded opacity-80 max-w-full"><p className="font-bold">{message.replyTo.displayName}</p><p className="text-gray-400 truncate break-words">{message.replyTo.text || "Image"}</p></div>)}
                            
                            {isEditing ? (
                                <div className="w-full">
                                    <textarea value={editedText} onChange={(e) => setEditedText(e.target.value)} className="w-full bg-gray-600 border border-gray-500 rounded-md py-2 px-3 text-white focus:outline-none focus:border-purple-500" rows="3"></textarea>
                                    <div className="text-right mt-1">
                                        <button onClick={() => setIsEditing(false)} className="text-xs text-gray-400 hover:text-white mr-2">Cancel</button>
                                        <button onClick={handleSaveEdit} className="text-xs bg-green-600 hover:bg-green-700 px-2 py-1 rounded">Save</button>
                                    </div>
                                </div>
                            ) : (
                                <div className={`px-4 py-2 rounded-lg inline-block relative break-words ${isOwnMessage ? 'rounded-br-none bg-purple-600 text-white' : 'rounded-bl-none bg-gray-700 text-gray-200'}`}>
                                    {message.imageUrl && <img src={message.imageUrl} className="max-w-full max-h-64 rounded-md mb-2" />}
                                    <ParsedMessageContent text={message.text} highlight={searchQuery} allUsers={allUsers} />
                                    {message.editedAt && <button onClick={() => setShowHistory(true)} className="text-xs text-blue-300 hover:underline ml-2">(edited)</button>}
                                </div>
                            )}
                        </div>
                        {!isEditing && <button onClick={() => onReply(message)} className={`self-end p-1 bg-gray-800 rounded-full text-gray-400 hover:text-white transition-opacity opacity-0 group-hover:opacity-100 flex-shrink-0 ${isOwnMessage ? 'ml-0 mr-2 order-first' : 'ml-2'}`}><svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M7.707 3.293a1 1 0 010 1.414L5.414 7H11a7 7 0 017 7v2a1 1 0 11-2 0v-2a5 5 0 00-5-5H5.414l2.293 2.293a1 1 0 11-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd"></path></svg></button>}
                    </div>

                     {contextMenu.visible && (
                         <div style={{ top: contextMenu.y, left: contextMenu.x }} className="absolute bg-gray-800 border border-gray-600 rounded-md shadow-lg py-1 z-50">
                             {!message.imageUrl && <button onClick={() => { setIsEditing(true); closeContextMenu(); }} className="block w-full text-left px-4 py-2 text-sm text-white hover:bg-blue-600">Edit Message</button>}
                             <button onClick={() => onRemove(message.id)} className="block w-full text-left px-4 py-2 text-sm text-red-500 hover:bg-red-600 hover:text-white">Remove Message</button>
                         </div>
                     )}
                     {showHistory && <EditHistoryModal history={message.editHistory} closeModal={() => setShowHistory(false)} />}
                </div>
            );
        }
        
        function MessageInput({ user, services, activeRoom, replyTo, setReplyTo, allUsers }) {
             const [newMessage, setNewMessage] = useState('');
             const [imageFile, setImageFile] = useState(null);
             const [imagePreview, setImagePreview] = useState(null);
             const [isUploading, setIsUploading] = useState(false);
             const fileInputRef = useRef(null);
             const uploadTaskRef = useRef(null);

             const compressImage = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const MAX_WIDTH = 800;
                            const scaleSize = (img.width > MAX_WIDTH) ? MAX_WIDTH / img.width : 1;
                            canvas.width = img.width * scaleSize;
                            canvas.height = img.height * scaleSize;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(new File([blob], file.name, { type: 'image/webp' }));
                                } else {
                                    reject(new Error('Canvas to Blob conversion failed.'));
                                }
                            }, 'image/webp', 0.8);
                        };
                        img.onerror = (err) => reject(err);
                    };
                    reader.onerror = (err) => reject(err);
                });
            };

             const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    setImageFile(file);
                    const reader = new FileReader();
                    reader.onloadend = () => { setImagePreview(reader.result); };
                    reader.readAsDataURL(file);
                }
                e.target.value = null;
             };

             const removeImage = () => {
                if (uploadTaskRef.current) {
                    uploadTaskRef.current.cancel();
                    uploadTaskRef.current = null;
                }
                 setImageFile(null);
                 setImagePreview(null);
                 setIsUploading(false);
             };

             const handleSendMessage = async (e) => {
                e.preventDefault();
                if (newMessage.trim() === '' && !imageFile) return;
                
                setIsUploading(true);

                let imageUrl = null;

                if (imageFile) {
                    try {
                        const compressedFile = await compressImage(imageFile);
                        const storageRef = services.ref(services.storage, `chat_images/${activeRoom.id}/${Date.now()}_${compressedFile.name}`);
                        
                        const uploadTask = services.uploadBytesResumable(storageRef, compressedFile);
                        uploadTaskRef.current = uploadTask;

                        imageUrl = await new Promise((resolve, reject) => {
                            const timeoutId = setTimeout(() => {
                                uploadTask.cancel();
                                reject(new Error('Image upload timed out after 5 seconds.'));
                            }, 5000);

                            uploadTask.on('state_changed', 
                                (snapshot) => {}, 
                                (error) => {
                                    clearTimeout(timeoutId);
                                    uploadTaskRef.current = null;
                                    reject(error);
                                }, 
                                async () => {
                                    clearTimeout(timeoutId);
                                    try {
                                        const downloadURL = await services.getDownloadURL(uploadTask.snapshot.ref);
                                        uploadTaskRef.current = null;
                                        resolve(downloadURL);
                                    } catch (error) {
                                        reject(error);
                                    }
                                }
                            );
                        });
                    } catch (error) {
                         if (error.code === 'storage/canceled') {
                            alert('Image upload was canceled.');
                        } else if (error.message.includes('timed out')) {
                            alert(error.message);
                        } else {
                            console.error("Error during image processing or upload: ", error);
                            let errorMessage = `Image upload failed: ${error.message}.`;
                             if (error.code === 'storage/unauthorized') {
                                errorMessage += "\nPlease check your Firebase Storage security rules to allow writes.";
                            } else if (error.code === 'storage/retry-limit-exceeded') {
                                 errorMessage += "\nThis can happen due to a poor network connection. Please try again."
                            }
                            alert(errorMessage);
                        }
                        removeImage();
                        setIsUploading(false);
                        return;
                    }
                }

                try {
                    const messagesPath = `artifacts/${appId}/public/data/rooms/${activeRoom.id}/messages`;
                    const messagesCollectionRef = services.collection(services.db, messagesPath);
                    const messageData = { text: newMessage, createdAt: services.serverTimestamp(), uid: user.uid, displayName: user.displayName, photoURL: user.photoURL };
                    if (imageUrl) { messageData.imageUrl = imageUrl; }
                    if (replyTo) { messageData.replyTo = { id: replyTo.id, text: replyTo.text, displayName: replyTo.displayName, imageUrl: replyTo.imageUrl }; }
                    await services.addDoc(messagesCollectionRef, messageData);
                    
                    setNewMessage('');
                    setReplyTo(null);
                    removeImage();
                } catch (error) { 
                    console.error("Error sending message: ", error);
                    alert("Failed to send message. Please try again.");
                } finally {
                    setIsUploading(false);
                }
            };
            return (
                 <div className="border-t-2 border-gray-700 px-4 pt-4 pb-4 flex-shrink-0">
                    {replyTo && (<div className="bg-gray-700 p-2 rounded-t-md text-sm mb-2"><div className="flex justify-between items-center font-bold"><p>Replying to {replyTo.displayName}</p><button onClick={() => setReplyTo(null)} className="text-gray-400 hover:text-white text-lg">&times;</button></div><p className="text-gray-400 truncate mt-1">{replyTo.imageUrl && !replyTo.text ? "Image" : replyTo.text}</p></div>)}
                    {imagePreview && (
                        <div className="mb-2 relative w-32">
                             <img src={imagePreview} className="rounded-lg max-h-32" />
                             <button onClick={removeImage} className="absolute -top-2 -right-2 bg-red-600 text-white rounded-full p-0.5 w-6 h-6 flex items-center justify-center">&times;</button>
                        </div>
                    )}
                    <form onSubmit={handleSendMessage} className="relative flex items-center">
                        <input type="file" accept="image/*" onChange={handleFileChange} ref={fileInputRef} className="hidden" />
                        <button type="button" onClick={() => fileInputRef.current.click()} disabled={isUploading} className="p-2 text-gray-400 hover:text-white disabled:opacity-50">
                             <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"></path></svg>
                        </button>
                        <input type="text" value={newMessage} onChange={(e) => setNewMessage(e.target.value)} placeholder={`Message #${activeRoom.name}`} disabled={isUploading} className="w-full focus:outline-none focus:placeholder-gray-400 text-gray-200 placeholder-gray-500 pl-4 pr-16 bg-gray-800 rounded-md py-3 border border-gray-600 focus:border-purple-500 disabled:opacity-50"/>
                        <div className="absolute right-0 items-center inset-y-0 flex">
                            <button type="submit" disabled={isUploading || (newMessage.trim() === '' && !imageFile)} className="inline-flex items-center justify-center rounded-lg px-3 py-2 transition duration-500 ease-in-out text-white bg-purple-600 hover:bg-purple-700 focus:outline-none mr-2 disabled:bg-gray-500 disabled:cursor-not-allowed">
                                {isUploading ? <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> : <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="h-6 w-6 transform rotate-90"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"></path></svg>}
                            </button>
                        </div>
                    </form>
                </div>
            );
        }

        function CreateRoomModal({ user, services, closeModal }) {
            const [roomName, setRoomName] = useState('');
            const [error, setError] = useState('');
            const handleCreateRoom = async (e) => {
                e.preventDefault();
                if (roomName.trim().length < 3) { setError('Room name must be at least 3 characters.'); return; }
                try {
                    const roomsPath = `artifacts/${appId}/public/data/rooms`;
                    const newRoomRef = services.doc(services.collection(services.db, roomsPath));
                    await services.setDoc(newRoomRef, { id: newRoomRef.id, name: roomName.trim(), type: 'private', isDM: false, createdBy: user.uid, createdAt: services.serverTimestamp(), members: [user.uid] });
                    closeModal();
                } catch (err) { console.error("Error creating room:", err); setError("Failed to create room."); }
            };
            return (<Modal title="Create a Group Chat" closeModal={closeModal}><form onSubmit={handleCreateRoom}><div className="mb-4"><label htmlFor="roomName" className="block text-gray-400 text-sm font-bold mb-2">Group Name</label><input id="roomName" type="text" value={roomName} onChange={(e) => setRoomName(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:border-purple-500" /></div>{error && <p className="text-red-400 text-sm text-center mb-4">{error}</p>}<div className="flex justify-end space-x-4"><button type="button" onClick={closeModal} className="text-gray-400 hover:text-white">Cancel</button><button type="submit" className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md">Create</button></div></form></Modal>);
        }

        function JoinRoomModal({ user, services, closeModal }) {
             const [roomId, setRoomId] = useState('');
             const [error, setError] = useState('');
             const [success, setSuccess] = useState('');
            const handleJoin = async (e) => {
                e.preventDefault();
                setError(''); setSuccess('');
                const trimmedRoomId = roomId.trim();
                if (trimmedRoomId === '') return;
                const roomRef = services.doc(services.db, `artifacts/${appId}/public/data/rooms`, trimmedRoomId);
                try {
                   const docSnap = await services.getDoc(roomRef);
                   if (docSnap.exists() && !docSnap.data().isDM) {
                       await services.updateDoc(roomRef, { members: services.arrayUnion(user.uid) });
                       setSuccess(`Successfully joined group!`);
                       setTimeout(closeModal, 1500);
                   } else { setError("No group found with this ID. Please check the ID and try again."); }
                } catch(err) { console.error("Error joining room: ", err); setError("An error occurred while trying to join the group."); }
            }
             return (<Modal title="Join a Group Chat" closeModal={closeModal}><form onSubmit={handleJoin}><label htmlFor="roomId" className="block text-gray-400 text-sm font-bold mb-2">Enter Group ID</label><input id="roomId" type="text" value={roomId} onChange={(e) => setRoomId(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:border-purple-500" />{error && <p className="text-red-400 text-sm text-center my-4">{error}</p>}{success && <p className="text-green-400 text-sm text-center my-4">{success}</p>}<div className="flex justify-end space-x-4 mt-6"><button type="button" onClick={closeModal} className="text-gray-400 hover:text-white">Cancel</button><button type="submit" className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md">Join</button></div></form></Modal>)
        }

        function AddFriendModal({ user, services, closeModal }) {
             const [friendCode, setFriendCode] = useState('');
             const [error, setError] = useState('');
             const [success, setSuccess] = useState('');
            const handleAddFriend = async (e) => {
                e.preventDefault();
                setError(''); setSuccess('');
                const code = friendCode.trim();
                if (!/^\d{4}$/.test(code)) { setError("Please enter a valid 4-digit Friend Code."); return; }
                if (code === user.friendCode) { setError("You can't add yourself as a friend."); return; }
                
                const usersRef = services.collection(services.db, `artifacts/${appId}/public/data/users`);
                const q = services.query(usersRef, services.where("friendCode", "==", code), services.limit(1));
                const querySnapshot = await services.getDocs(q);

                if (querySnapshot.empty) { setError("User not found."); return; }

                const friendDoc = querySnapshot.docs[0];
                const friendData = friendDoc.data();

                const requestRef = services.doc(services.db, `artifacts/${appId}/public/data/users/${friendData.uid}/friendRequests`, user.uid);
                await services.setDoc(requestRef, {
                    from: user.uid, displayName: user.displayName, photoURL: user.photoURL, status: 'pending', createdAt: services.serverTimestamp()
                });
                
                setSuccess("Friend request sent!");
                setTimeout(closeModal, 1500);
            }
             return (
                 <Modal title="Add a Friend" closeModal={closeModal}>
                     <p className="text-sm text-gray-400 mb-4">Enter your friend's 4-digit code to send a request.</p>
                     <form onSubmit={handleAddFriend}>
                        <label htmlFor="friendCode" className="block text-gray-400 text-sm font-bold mb-2">Friend Code</label>
                        <input id="friendCode" type="text" value={friendCode} onChange={(e) => setFriendCode(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:border-purple-500" maxLength="4" />
                        {error && <p className="text-red-400 text-sm text-center my-4">{error}</p>}
                        {success && <p className="text-green-400 text-sm text-center my-4">{success}</p>}
                        <div className="flex justify-end space-x-4 mt-6"><button type="button" onClick={closeModal} className="text-gray-400 hover:text-white">Cancel</button><button type="submit" className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md">Send Request</button></div>
                     </form>
                 </Modal>
            )
        }

        function ProfileModal({ user, services, closeModal }) {
            const { db, storage } = services;
            const [displayName, setDisplayName] = useState(user.displayName || '');
            const [isUploading, setIsUploading] = useState(false);
            const [error, setError] = useState('');
            const profilePicInputRef = useRef(null);
            const handleUpdateProfile = async (e) => {
                e.preventDefault();
                if(!displayName.trim()) { setError('Display name cannot be empty.'); return; }
                setError('');
                const userDocRef = services.doc(db, `artifacts/${appId}/public/data/users/${user.uid}`);
                try { await services.updateDoc(userDocRef, { displayName }); closeModal(); } 
                catch(err) { console.error("Error updating display name:", err); setError('Failed to update profile.'); }
            };
            const handleProfilePicChange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (!file.type.startsWith('image/')) { setError('Please select an image file.'); return; }
                if (file.size > 5 * 1024 * 1024) { setError('File size should not exceed 5MB.'); return; }
                setError(''); setIsUploading(true);
                const storageRef = services.ref(storage, `profile_pics/${user.uid}`);
                try {
                    await services.uploadBytes(storageRef, file);
                    const downloadURL = await services.getDownloadURL(storageRef);
                    const userDocRef = services.doc(db, `artifacts/${appId}/public/data/users/${user.uid}`);
                    await services.updateDoc(userDocRef, { photoURL: downloadURL });
                } catch(err) { console.error("Error uploading profile picture:", err); setError('Failed to upload picture.'); } 
                finally { setIsUploading(false); }
            };
            return (
                <Modal title="Edit Profile" closeModal={closeModal}>
                    <div className="flex flex-col items-center mb-6">
                         <img src={user.photoURL || `https://placehold.co/96x96/374151/E5E7EB?text=${(displayName || 'U')[0]}`} alt="Profile" className="w-24 h-24 rounded-full mb-4 object-cover" />
                         <input type="file" accept="image/*" ref={profilePicInputRef} onChange={handleProfilePicChange} className="hidden" />
                         <button onClick={() => profilePicInputRef.current.click()} disabled={isUploading} className="bg-gray-700 hover:bg-gray-600 text-white text-sm py-1 px-3 rounded-md disabled:opacity-50">{isUploading ? 'Uploading...' : 'Change Picture'}</button>
                    </div>
                    {error && <p className="text-red-400 text-sm text-center mb-4">{error}</p>}
                    <form onSubmit={handleUpdateProfile}>
                        <div className="mb-4">
                            <label className="block text-gray-400 text-sm font-bold mb-2">Your Friend Code</label>
                            <p className="w-full bg-gray-900 rounded-md py-2 px-3 text-white text-lg tracking-widest font-mono text-center">{user.friendCode}</p>
                        </div>
                        <div className="mb-4">
                            <label htmlFor="displayName" className="block text-gray-400 text-sm font-bold mb-2">Display Name</label>
                            <input id="displayName" type="text" value={displayName} onChange={(e) => setDisplayName(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:border-purple-500"/>
                        </div>
                        <div className="flex items-center justify-end space-x-4"><button type="button" onClick={closeModal} className="text-gray-400 hover:text-white">Cancel</button><button type="submit" className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md focus:outline-none">Save</button></div>
                    </form>
                </Modal>
            );
        }

        function Modal({ title, children, closeModal }) {
             return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4" onClick={closeModal}>
                    <div className="bg-gray-800 rounded-lg w-full max-w-2xl max-h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
                        <div className="flex-shrink-0 flex justify-between items-center p-6 border-b border-gray-700">
                            <h2 className="text-2xl font-bold text-white">{title}</h2>
                            <button onClick={closeModal} className="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
                        </div>
                        <div className="flex-grow p-6 overflow-y-auto">
                            {children}
                        </div>
                    </div>
                </div>
            );
        }
        
        function MediaViewerModal({ messages, closeModal }) {
            const mediaMessages = messages.filter(msg => msg.imageUrl);

            return (
                <Modal title="Media Files" closeModal={closeModal}>
                    {mediaMessages.length > 0 ? (
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 max-h-96 overflow-y-auto">
                            {mediaMessages.map(msg => (
                                <a key={msg.id} href={msg.imageUrl} target="_blank" rel="noopener noreferrer">
                                    <img src={msg.imageUrl} alt="Chat media" className="rounded-lg object-cover w-full h-32 hover:opacity-80 transition-opacity" />
                                </a>
                            ))}
                        </div>
                    ) : (
                        <p className="text-gray-400 text-center">No media files found in this conversation.</p>
                    )}
                </Modal>
            )
        }
        
        function LinksViewerModal({ messages, closeModal }) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const links = messages.reduce((acc, msg) => {
                if (msg.text) {
                    const foundLinks = msg.text.match(urlRegex);
                    if (foundLinks) {
                        return acc.concat(foundLinks.map(link => ({ id: msg.id + link, link })));
                    }
                }
                return acc;
            }, []);
            const uniqueLinks = Array.from(new Set(links.map(l => l.link)))
                .map(link => {
                    return links.find(l => l.link === link)
                });

            return (
                <Modal title="Links" closeModal={closeModal}>
                    {uniqueLinks.length > 0 ? (
                        <ul className="space-y-3 max-h-96 overflow-y-auto">
                            {uniqueLinks.map(({ id, link }) => (
                                <li key={id} className="bg-gray-700 p-2 rounded-md">
                                    <a href={link} target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:underline break-all">
                                        {link}
                                    </a>
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p className="text-gray-400 text-center">No links found in this conversation.</p>
                    )}
                </Modal>
            )
        }

        function EditHistoryModal({ history, closeModal }) {
            return (
                <Modal title="Message Edit History" closeModal={closeModal}>
                    <ul className="space-y-4 max-h-96 overflow-y-auto">
                        {history && history.length > 0 ? (
                            history.slice().reverse().map((edit, index) => (
                                <li key={index} className="bg-gray-700 p-3 rounded-md">
                                    <p className="text-white break-words">{edit.originalText}</p>
                                    <p className="text-xs text-gray-400 mt-2">Edited on: {new Date(edit.editedAt).toLocaleString()}</p>
                                </li>
                            ))
                        ) : (
                            <p className="text-gray-400 text-center">No edit history available.</p>
                        )}
                    </ul>
                </Modal>
            );
        }

        function EmoticonManagerModal({ user, services, closeModal }) {
            const [emoticons, setEmoticons] = useState(user.customEmoticons || []);
            const [newShortcut, setNewShortcut] = useState('');
            const [newImage, setNewImage] = useState(null);
            const [error, setError] = useState('');
            const [isUploading, setIsUploading] = useState(false);
            const fileInputRef = useRef(null);

            const handleAddEmoticon = async (e) => {
                e.preventDefault();
                if (!newShortcut.trim() || !newImage) {
                    setError('Both shortcut and image are required.');
                    return;
                }
                if (!newShortcut.startsWith(':') || !newShortcut.endsWith(':')) {
                    setError('Shortcut must start and end with a colon (e.g., :happy:).');
                    return;
                }
                if ((user.customEmoticons || []).some(em => em.shortcut === newShortcut.trim())) {
                    setError('This shortcut is already in use.');
                    return;
                }

                setError('');
                setIsUploading(true);

                try {
                    const storageRef = services.ref(services.storage, `emoticons/${user.uid}/${Date.now()}_${newImage.name}`);
                    await services.uploadBytes(storageRef, newImage);
                    const imageUrl = await services.getDownloadURL(storageRef);

                    const userDocRef = services.doc(services.db, `artifacts/${appId}/public/data/users/${user.uid}`);
                    const newEmoticon = { shortcut: newShortcut.trim(), imageUrl, storagePath: storageRef.fullPath };
                    
                    await services.updateDoc(userDocRef, {
                        customEmoticons: services.arrayUnion(newEmoticon)
                    });

                    setEmoticons(prev => [...prev, newEmoticon]);
                    setNewShortcut('');
                    setNewImage(null);
                    if(fileInputRef.current) fileInputRef.current.value = null;

                } catch (err) {
                    console.error("Error adding emoticon:", err);
                    setError("Failed to add emoticon. Please try again.");
                } finally {
                    setIsUploading(false);
                }
            };

            const handleDeleteEmoticon = async (emoticonToDelete) => {
                try {
                    const userDocRef = services.doc(services.db, `artifacts/${appId}/public/data/users/${user.uid}`);
                    await services.updateDoc(userDocRef, {
                        customEmoticons: services.arrayRemove(emoticonToDelete)
                    });
                    
                    const storageRef = services.ref(services.storage, emoticonToDelete.storagePath);
                    await services.deleteObject(storageRef);

                    setEmoticons(prev => prev.filter(em => em.shortcut !== emoticonToDelete.shortcut));

                } catch (err) {
                    console.error("Error deleting emoticon:", err);
                    alert("Failed to delete emoticon.");
                }
            };

            return (
                <Modal title="Custom Emoticons" closeModal={closeModal}>
                    <div className="space-y-4">
                        <form onSubmit={handleAddEmoticon} className="p-4 bg-gray-700 rounded-lg">
                            <h3 className="text-lg font-semibold mb-2 text-white">Add New Emoticon</h3>
                            <div className="flex flex-col space-y-3">
                                <input 
                                    type="text" 
                                    value={newShortcut} 
                                    onChange={(e) => setNewShortcut(e.target.value)} 
                                    placeholder="e.g., :happy:" 
                                    className="w-full bg-gray-800 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:border-purple-500"
                                />
                                <input 
                                    type="file" 
                                    accept="image/*"
                                    ref={fileInputRef}
                                    onChange={(e) => setNewImage(e.target.files[0])}
                                    className="text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-600 file:text-white hover:file:bg-purple-700"
                                />
                            </div>
                            {error && <p className="text-red-400 text-sm text-center mt-3">{error}</p>}
                            <button type="submit" disabled={isUploading} className="w-full mt-4 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md disabled:opacity-50">
                                {isUploading ? 'Uploading...' : 'Add Emoticon'}
                            </button>
                        </form>

                        <div>
                            <h3 className="text-lg font-semibold mb-2 text-white">Your Emoticons</h3>
                            <div className="max-h-60 overflow-y-auto space-y-2 pr-2">
                                {emoticons.length > 0 ? (
                                    emoticons.map(emoticon => (
                                        <div key={emoticon.shortcut} className="flex items-center justify-between bg-gray-700 p-2 rounded-md">
                                            <div className="flex items-center">
                                                <img src={emoticon.imageUrl} alt={emoticon.shortcut} className="w-8 h-8 mr-3"/>
                                                <span className="text-white">{emoticon.shortcut}</span>
                                            </div>
                                            <button onClick={() => handleDeleteEmoticon(emoticon)} className="text-red-500 hover:text-red-400 font-bold text-xl">&times;</button>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-gray-400 text-center py-4">You haven't added any custom emoticons yet.</p>
                                )}
                            </div>
                        </div>
                    </div>
                </Modal>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>

</body>
</html>